import{_ as a,c as t,l as e,I as r,w as n,ak as i,D as o,o as l,a as u}from"./chunks/framework.CrObIqqD.js";const p="/k-centipede/assets/requetes_kano.C9UaaUu4.jpg",T=JSON.parse('{"title":"Exploiter les données de Centipède en webmapping","description":"","frontmatter":{},"headers":[],"relativePath":"04_exploiter/webmapping.md","filePath":"04_exploiter/webmapping.md"}'),c={name:"04_exploiter/webmapping.md"},d=i('<h1 id="exploiter-les-donnees-de-centipede-en-webmapping" tabindex="-1">Exploiter les données de Centipède en webmapping <a class="header-anchor" href="#exploiter-les-donnees-de-centipede-en-webmapping" aria-label="Permalink to &quot;Exploiter les données de Centipède en webmapping&quot;">​</a></h1><h2 id="les-bases-du-webmapping" tabindex="-1">Les bases du webmapping <a class="header-anchor" href="#les-bases-du-webmapping" aria-label="Permalink to &quot;Les bases du webmapping&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">Définition Webmapping</p><p>Correspond à la diffusion de données cartographiques par le biais d&#39;un site web. Les informations affichées sont la réponse de requêtes clientes : on parle d&#39;affichage dynamique.</p></div><h3 id="l-architecture-d-une-solution-webmapping" tabindex="-1">L&#39;architecture d&#39;une solution webmapping <a class="header-anchor" href="#l-architecture-d-une-solution-webmapping" aria-label="Permalink to &quot;L&#39;architecture d&#39;une solution webmapping&quot;">​</a></h3><p>Une solution webmapping s&#39;articule atour de 3 piliers :</p><ul><li>Les requêtes ;</li><li>Le traitement ;</li><li>L&#39;affichage.</li></ul><h4 id="les-requetes" tabindex="-1">Les requêtes <a class="header-anchor" href="#les-requetes" aria-label="Permalink to &quot;Les requêtes&quot;">​</a></h4><p>Une requête est une demande effectuée par un utilisateur. Elle suit le protocole de communication HTTP, et permet à un utilisateur d&#39;accéder à des ressources (docs HTML ou programmes) stockées dans des bases de données grâce à leur URL.</p><p>Une requête HTTP est composée d&#39;un en-tête <em>HEAD</em> et d&#39;un corps <em>BODY</em> dans lesquels est encapsulée la requête selon une méthode choisie (GET ou POST majoritairement).</p><p>Un requête HTTP contient donc :</p><ul><li>L&#39;URL du fichier ou du programme recherché ;</li><li>La méthode de requête (GET, POST, etc.) ;</li><li>Les paramètres que la ressource recherchée devra appliquer (taille, etc.).</li></ul><p>Dans la majorité des sites web dynamiques modernes, les requêtes sont traitées par des <em>controls</em>. Ils permettent de définir au sein d&#39;une page HTML des objets Javascript, capables de répondre localement aux requêtes client en arrière plan, sans recharger toute la page web. On parle de site web AJAX.</p><p>Ces sites AJAX sont agrémentés de composants pré-programmés nommés widgets. Ils facilitent le développement de sites web interactifs.</p><p>Finalement, un site de webmapping est un assemblage sur-mesure de composants préprogrammés, capables de répondre à plusieurs types de requêtes clientes. On parle de <em>Mashup</em>.</p><h4 id="le-traitement" tabindex="-1">Le traitement <a class="header-anchor" href="#le-traitement" aria-label="Permalink to &quot;Le traitement&quot;">​</a></h4><p>Une fois la requête client émise, les logiciels de traitement localisent la ressource recherchée, l&#39;exécutent si besoin, et retournent le résultat au client.</p><h4 id="l-affichage-et-stockage" tabindex="-1">L&#39;affichage et stockage <a class="header-anchor" href="#l-affichage-et-stockage" aria-label="Permalink to &quot;L&#39;affichage et stockage&quot;">​</a></h4><p>Selon le format de la réponse reçue, l&#39;affichage peut être direct (page HTML), ou indirect en faisant appel à des logiciels d&#39;interprétation (Javascript, Flash, etc.). C&#39;est notamment le cas des données vectorielles, qui nécessitent un traitement sur l&#39;appareil client.</p><p>Selon la nature de la requête, la ressource peut aussi être stockée dans une base de données, pour un affichage ultérieur.</p><h3 id="interoperabilite-et-normes-ogc" tabindex="-1">Interopérabilité et normes OGC <a class="header-anchor" href="#interoperabilite-et-normes-ogc" aria-label="Permalink to &quot;Interopérabilité et normes OGC&quot;">​</a></h3><p>Les solutions webmapping font appel à de multiples serveurs géographiques. Pour garantir l&#39;<strong>interopérabilité</strong> des données et services géographiques, l&#39;Open Geospatial Consortium (OGC) a déceloppé des standarts de communicaction, de formatage et d&#39;échange.</p><details class="details custom-block"><summary>WMS</summary><p>Les services WMS (Web Map Service) permettent de mettre à disposition d’utilisateurs des <strong>images géoréférencées</strong>, via une simple requête HTTP, à partir de données sources raster (image) ou vecteur.</p><p>Les services WMS <strong>calculent les images</strong> demandées selon divers paramètres fournis dans la requête.</p><p>Les services WMS se composent de 3 requêtes :</p><ul><li><em>GetCapabilities</em> : renvoie les paramètres du service et les couches (une couche WMS correspond à une ressource) disponibles avec les informations permettant de paramétrer les requêtes suivantes ;</li><li><em>GetMap</em> : renvoie une image de la carte ;</li><li><em>GetFeatureInfo</em> : renvoie des informations sur les objets ayant servi à générer la carte (optionnelle).</li></ul></details><details class="details custom-block"><summary>WMTS</summary><p>Les services d’images tuilées permettent de mettre à disposition d’utilisateurs distants des images géoréférencées, via une simple requête HTTP.</p><p>Ils mettent en œuvre le protocole WMTS (Web Map Tile Service).</p><p>Les requêtes WMTS sont des références directes aux images demandées dans un système de cache précalculé. Cela permet d’avoir des temps de réponse nettement plus rapides que pour le WMS qui doit calculer une image côté serveur à chaque requête.</p><p>Le cache d’images repose sur un maillage rectangulaire régulier de la zone couverte, une image étant associée à chaque maille (appelée aussi tuile). Pour pouvoir représenter cette zone à différents niveaux d’échelles (ou niveaux de zoom), des maillages de plus en plus fins sont définis pour la zone. Le cache d’images ainsi tuilées apparaît donc comme une pyramide dont chaque niveau de zoom représente un étage. Chaque type de donnée servie (Orthoimagerie, cartes, …) nécessite ainsi le pré-calcul d’une telle cache dans une projection donnée, hébergée sur l’infrastructure Géoportail.</p><p>Pour obtenir une image, une requête WMTS comporte donc des paramètres précisant : le type de données (LAYER), la pyramide de tuiles (TILEMATRIXSET) et le maillage (TILEMATRIX) correspondant au niveau de zoom voulu et les coordonnées de la tuile dans ce maillage (TILECOL et TILEROW). (<a href="https://geoservices.ign.fr/documentation/services/api-et-services-ogc#2430" target="_blank" rel="noreferrer">IGN, 2023</a>)</p></details><details class="details custom-block"><summary>WCS</summary><p>Le Web Coverage Service (WCS) est un service d&#39;échanges de données raster complexes. Les données WCS sont souvent utilisées dans le cadre de modélisations, qui font appel à des données raster plus complètes que celles transportées grâce aux services WMS.</p></details><details class="details custom-block"><summary>WFS</summary><p>Le service WFS permet aux utilisateurs de télécharger des données vectorielles géoréférencées.</p></details><details class="details custom-block"><summary>CSW</summary><p>Le service CSW du Géoportail permet d’interroger des catalogues de données.</p></details><h2 id="le-fonctionnement-de-kano" tabindex="-1">Le fonctionnement de Kano <a class="header-anchor" href="#le-fonctionnement-de-kano" aria-label="Permalink to &quot;Le fonctionnement de Kano&quot;">​</a></h2><p>L&#39;architecture de la solution webmapping Kano est articulée autour de 2 systèmes de requêtes imbriqués l&#39;un dans l&#39;autre, avec un point de croisement : le gestionnaire de bases de données MongoDB.</p><p>D&#39;un coté, le JOB lance des requête régulières au serveur Centipède pour en récupérer la liste des bases disponibles et la stocker sur MongoDB. De l&#39;autre, l&#39;utilisateur interroge MongoDB (via Kano) pour en extraire la liste des bases précédemment collectée grâce au travail du JOB.</p><p>Ce schéma récapitule ce système à double requêtes :</p>',30),m=e("img",{src:p,alt:"Impossible de visualiser le contenu",style:{display:"block",margin:"0 auto"}},null,-1);function g(h,b,f,q,v,L){const s=o("center");return l(),t("div",null,[d,e("p",null,[m,e("em",null,[r(s,null,{default:n(()=>[u(" Réponse à une requête utilisateur sur Kano")]),_:1})])])])}const k=a(c,[["render",g]]);export{T as __pageData,k as default};
